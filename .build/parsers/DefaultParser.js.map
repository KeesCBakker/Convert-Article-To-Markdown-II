{
  "version": 3,
  "sources": ["../../parsers/DefaultParser.ts"],
  "sourcesContent": ["import { parseHTML } from 'linkedom'\nimport { NodeHtmlMarkdown } from 'node-html-markdown'\nimport { scrape } from \"./scraper\"\n\nexport function elementToMarkdown(element: HTMLElement | null) {\n  let html = element?.innerHTML || \"\"\n  let content = NodeHtmlMarkdown.translate(html).trim()\n  return content\n}\n\nexport class DefaultParser implements IParser {\n\n  protected _url?: URL | null = null\n\n  canParse(url: URL) {\n    if (url)\n      return true\n    return false\n  }\n\n  async parse(url: URL) {\n\n    this._url = url\n    let txt = await scrape(url)\n\n    const { document } = parseHTML(txt)\n\n    this.preParse(document)\n\n    let article = this.getArticleNode(document)\n    let content = elementToMarkdown(article)\n    let header = this.parseHeader(document)\n    content = header + content\n    return content\n  }\n\n  protected preParse(document: Document) {\n\n    // parse embeds\n    document.querySelectorAll('iframe').forEach(iframe => {\n      if (!iframe.src)\n        return\n\n      const url = new URL(iframe.src)\n      const type = url.host\n      const name = url.pathname\n\n      const p = document.createElement(\"p\")\n      const n = document.createTextNode(`{% ${type} ${name} %}`)\n      p.appendChild(n)\n\n      iframe.parentNode?.insertBefore(p, iframe)\n    })\n  }\n\n  protected getArticleNode(document: Document): HTMLElement | null {\n    return (\n      document.querySelector('article') ||\n      document.querySelector('body')\n    )\n  }\n\n  protected parseHeader(document: Document) {\n\n    let header = '---\\n'\n\n    let title = (document.querySelector('h1')?.textContent || '').trim()\n    if (title) {\n      header += `title: ${title}\\n`\n    }\n\n    let tagSelector = this.getTagSelector()\n    let tags = [...document.querySelectorAll(tagSelector)]\n      .map(a => (a.textContent || '').trim().toLowerCase())\n      .filter(t => t)\n      .map(a => a.replace('node.js', 'node'))\n    if (tags.length > 0) {\n      tags.sort()\n      let t = [...new Set(tags)].join(\", \")\n      header += `tags: [${t}]\\n`\n    }\n\n    let canonical = document.querySelector('link[rel=canonical]')?.getAttribute(\"href\") || this._url\n    if (canonical) {\n      header += `canonical_url: ${canonical}\\n`\n    }\n\n    header += '---\\n\\n'\n\n    return header\n  }\n\n  protected getTagSelector() {\n    return \".categories a, .tags a\"\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA,sBAA0B;AAC1B,gCAAiC;AACjC,qBAAuB;AAEhB,2BAA2B,SAA6B;AAC7D,MAAI,OAAO,oCAAS,cAAa;AACjC,MAAI,UAAU,2CAAiB,UAAU,MAAM;AAC/C,SAAO;AAAA;AAGF,oBAAuC;AAAA,EAElC,OAAoB;AAAA,EAE9B,SAAS,KAAU;AACjB,QAAI;AACF,aAAO;AACT,WAAO;AAAA;AAAA,QAGH,MAAM,KAAU;AAEpB,SAAK,OAAO;AACZ,QAAI,MAAM,MAAM,2BAAO;AAEvB,UAAM,EAAE,aAAa,+BAAU;AAE/B,SAAK,SAAS;AAEd,QAAI,UAAU,KAAK,eAAe;AAClC,QAAI,UAAU,kBAAkB;AAChC,QAAI,SAAS,KAAK,YAAY;AAC9B,cAAU,SAAS;AACnB,WAAO;AAAA;AAAA,EAGC,SAAS,UAAoB;AAGrC,aAAS,iBAAiB,UAAU,QAAQ,YAAU;AAvC1D;AAwCM,UAAI,CAAC,OAAO;AACV;AAEF,YAAM,MAAM,IAAI,IAAI,OAAO;AAC3B,YAAM,OAAO,IAAI;AACjB,YAAM,OAAO,IAAI;AAEjB,YAAM,IAAI,SAAS,cAAc;AACjC,YAAM,IAAI,SAAS,eAAe,MAAM,QAAQ;AAChD,QAAE,YAAY;AAEd,mBAAO,eAAP,mBAAmB,aAAa,GAAG;AAAA;AAAA;AAAA,EAI7B,eAAe,UAAwC;AAC/D,WACE,SAAS,cAAc,cACvB,SAAS,cAAc;AAAA;AAAA,EAIjB,YAAY,UAAoB;AA9D5C;AAgEI,QAAI,SAAS;AAEb,QAAI,QAAS,iBAAS,cAAc,UAAvB,mBAA8B,gBAAe,IAAI;AAC9D,QAAI,OAAO;AACT,gBAAU,UAAU;AAAA;AAAA;AAGtB,QAAI,cAAc,KAAK;AACvB,QAAI,OAAO,CAAC,GAAG,SAAS,iBAAiB,cACtC,IAAI,OAAM,GAAE,eAAe,IAAI,OAAO,eACtC,OAAO,OAAK,GACZ,IAAI,OAAK,EAAE,QAAQ,WAAW;AACjC,QAAI,KAAK,SAAS,GAAG;AACnB,WAAK;AACL,UAAI,IAAI,CAAC,GAAG,IAAI,IAAI,OAAO,KAAK;AAChC,gBAAU,UAAU;AAAA;AAAA;AAGtB,QAAI,YAAY,gBAAS,cAAc,2BAAvB,mBAA+C,aAAa,YAAW,KAAK;AAC5F,QAAI,WAAW;AACb,gBAAU,kBAAkB;AAAA;AAAA;AAG9B,cAAU;AAEV,WAAO;AAAA;AAAA,EAGC,iBAAiB;AACzB,WAAO;AAAA;AAAA;",
  "names": []
}
